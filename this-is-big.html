<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><title>const关键字 - fly</title><meta name="description" content="const关键字 const是constant的简写，只要一个变量前面用const来修饰，就意味着该变量里的数据可以被访问，不能被修改。也就是说const意味着只读（readonly）。 规则：const离谁近，谁就不能被修改； const修饰一个变量，一定要给这个变量初始化值，若不初始化，后面就无法初始化。 本质：const在谁后面谁就不可以修改，const在最前面则将其后移一位，二者等效。 const关键字作用 const关键字应用 Bjarne在他的The C++ Programming Language里面给出过一个助记的方法：把一个声明从右向左读。 char * const cp; ( * 读成 pointer to&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://yylh.github.io/fly/this-is-big.html"><link rel="alternate" type="application/atom+xml" href="https://yylh.github.io/fly/feed.xml"><link rel="alternate" type="application/json" href="https://yylh.github.io/fly/feed.json"><meta property="og:title" content="const关键字 - fly "><meta property="og:image" content="https://yylh.github.io/fly/media/website/act746.png"><meta property="og:site_name" content="fly"><meta property="og:description" content="const关键字 const是constant的简写，只要一个变量前面用const来修饰，就意味着该变量里的数据可以被访问，不能被修改。也就是说const意味着只读（readonly）。 规则：const离谁近，谁就不能被修改； const修饰一个变量，一定要给这个变量初始化值，若不初始化，后面就无法初始化。 本质：const在谁后面谁就不可以修改，const在最前面则将其后移一位，二者等效。 const关键字作用 const关键字应用 Bjarne在他的The C++ Programming Language里面给出过一个助记的方法：把一个声明从右向左读。 char * const cp; ( * 读成 pointer to&hellip;"><meta property="og:url" content="https://yylh.github.io/fly/this-is-big.html"><meta property="og:type" content="article"><link rel="stylesheet" href="https://yylh.github.io/fly/assets/css/fontawesome-all.min.css?v=bbcde81f26378440dac4c3d195714389"><link rel="stylesheet" href="https://yylh.github.io/fly/assets/css/style.css?v=d7e7f41de98b50d6bffc16a612f16045"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://yylh.github.io/fly/this-is-big.html"},"headline":"const关键字","datePublished":"2022-08-17T17:10","dateModified":"2022-08-25T17:54","description":"const关键字 const是constant的简写，只要一个变量前面用const来修饰，就意味着该变量里的数据可以被访问，不能被修改。也就是说const意味着只读（readonly）。 规则：const离谁近，谁就不能被修改； const修饰一个变量，一定要给这个变量初始化值，若不初始化，后面就无法初始化。 本质：const在谁后面谁就不可以修改，const在最前面则将其后移一位，二者等效。 const关键字作用 const关键字应用 Bjarne在他的The C++ Programming Language里面给出过一个助记的方法：把一个声明从右向左读。 char * const cp; ( * 读成 pointer to&hellip;","author":{"@type":"Person","name":"fly","url":"https://yylh.github.io/fly/authors/fly/"},"publisher":{"@type":"Organization","name":"fly"}}</script></head><body class="is-preload"><div id="wrapper"><div id="main"><div class="inner"><header id="header"><a class="logo" href="https://yylh.github.io/fly/"><strong>fly</strong></a></header><article class="post"><header class="main post__header"><time datetime="2022-08-17T17:10" class="post__date">August 17, 2022</time><h1>const关键字</h1></header><div class="post__inner post__entry"><p data-title="C++ const 关键字" data-commid="11267,15416, 16271">const关键字</p><p><strong>         const</strong>是<strong>constant</strong>的简写，只要一个变量前面用const来修饰，就意味着该变量里的数据可以被访问，不能被修改。也就是说const意味着只读（readonly）。</p><p><strong>规则：const离谁近，谁就不能被修改；</strong></p><p>const修饰一个变量，一定要给这个变量初始化值，若不初始化，后面就无法初始化。</p><p><strong>本质：const在谁后面谁就不可以修改，const在最前面则将其后移一位，二者等效。</strong></p><p><strong>const关键字作用</strong></p><ul><li><i class="fa fa-circle" aria-hidden="true"></i>为给读你代码的人传达非常有用的信息，声明一个参数为常量是为了告诉用户这个参数的应用目的；</li><li><i class="fa fa-circle" aria-hidden="true"></i>通过给优化器一些附加信息，使关键字const也许能产生更紧凑的代码；</li><li><i class="fa fa-circle" aria-hidden="true"></i>合理使用关键字const可以使编译器很自然的保护那些不希望被修改的参数，防止无意的代码修改，可以减少bug的出现；</li></ul><p><strong>const关键字应用</strong></p><ul><li><i class="fa fa-circle" aria-hidden="true"></i>欲阻止一个变量被改变，可使用const，在定义该const变量时，需先初始化，以后就没有机会改变他了；</li><li><i class="fa fa-circle" aria-hidden="true"></i>对指针而言，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；</li><li><i class="fa fa-circle" aria-hidden="true"></i>在一个函数声明中，const可以修饰形参表明他是一个输入参数，在函数内部不可以改变其值；</li><li><i class="fa fa-circle" aria-hidden="true"></i>对于类的成员函数，有时候必须指定其为const类型，表明其是一个常函数，不能修改类的成员变量；</li><li><i class="fa fa-circle" aria-hidden="true"></i>对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。</li></ul><hr><h2 class="align-center">const char*, char const*, char*const 的区别</h2><p>Bjarne在他的The C++ Programming Language里面给出过一个助记的方法：<strong>把一个声明从右向左读</strong>。</p><pre class="prettyprint prettyprinted"><span class="kwd">char</span> <span class="pun">*</span> <span class="kwd">const</span><span class="pln"> cp</span><span class="pun">;</span> <span class="pun">(</span> <span class="pun">*</span> <span class="pun">读成</span><span class="pln"> pointer to </span><span class="pun">)</span><span class="pln"> 
cp </span><span class="kwd">is</span><span class="pln"> a </span><span class="kwd">const</span><span class="pln"> pointer to </span><span class="kwd">char</span> 

<span class="kwd">const</span> <span class="kwd">char</span> <span class="pun">*</span><span class="pln"> p</span><span class="pun">;</span><span class="pln"> 
p </span><span class="kwd">is</span><span class="pln"> a pointer to </span><span class="kwd">const</span> <span class="kwd">char</span><span class="pun">;</span> 

<span class="kwd">char</span> <span class="kwd">const</span> <span class="pun">*</span><span class="pln"> p</span><span class="pun">;</span> <br><span class="pln">p </span><span class="kwd">is</span><span class="pln"> a pointer to </span><span class="kwd">const</span> <span class="kwd">char</span><span class="pun">;</span> </pre><p>同上因为C++里面没有const*的运算符，所以const只能属于前面的类型。</p><p>修饰指针的情况比较多，主要有以下几种情况：</p><p>1、const 修饰 <strong>*p</strong>，指向的对象只读，指针的指向可变：</p><pre class="prettyprint prettyprinted"><span class="kwd">int</span><span class="pln"> a </span><span class="pun">=</span> <span class="lit">9</span><span class="pun">;</span>
<span class="kwd">int</span><span class="pln"> b </span><span class="pun">=</span> <span class="lit">10</span><span class="pun">;</span>
<span class="kwd">const</span> <span class="kwd">int</span> <span class="pun">*</span><span class="pln">p </span><span class="pun">=</span> <span class="pun">&amp;</span><span class="pln">a</span><span class="pun">;</span><span class="com">//p是一个指向int类型的const值,与int const *p等价</span>
<span class="pun">*</span><span class="pln">p </span><span class="pun">=</span> <span class="lit">11</span><span class="pun">;</span>    <span class="com">//编译错误，指向的对象是只读的，不可通过p进行改变</span><span class="pln">
p </span><span class="pun">=</span> <span class="pun">&amp;</span><span class="pln">b</span><span class="pun">;</span>     <span class="com">//合法，改变了p的指向</span></pre><p>这里为了便于理解，可认为const修饰的是 *p，通常使用 <strong>*</strong> 对指针进行解引用来访问对象，因而，该对象是只读的。</p><p>2、const 修饰 p，指向的对象可变，指针的指向不可变：</p><pre class="prettyprint prettyprinted"><span class="kwd">int</span><span class="pln"> a </span><span class="pun">=</span> <span class="lit">9</span><span class="pun">;</span>
<span class="kwd">int</span><span class="pln"> b </span><span class="pun">=</span> <span class="lit">10</span><span class="pun">;</span>
<span class="kwd">int</span> <span class="pun">*</span> <span class="kwd">const</span><span class="pln"> p </span><span class="pun">=</span> <span class="pun">&amp;</span><span class="pln">a</span><span class="pun">;</span><span class="com">//p是一个const指针</span>
<span class="pun">*</span><span class="pln">p </span><span class="pun">=</span> <span class="lit">11</span><span class="pun">;</span>    <span class="com">//合法，</span><span class="pln">
p </span><span class="pun">=</span> <span class="pun">&amp;</span><span class="pln">b</span><span class="pun">;</span>     <span class="com">//编译错误，p是一个const指针，只读，不可变</span></pre><p>3、指针不可改变指向，指向的内容也不可变</p><pre class="prettyprint prettyprinted"><span class="kwd">int</span><span class="pln"> a </span><span class="pun">=</span> <span class="lit">9</span><span class="pun">;</span>
<span class="kwd">int</span><span class="pln"> b </span><span class="pun">=</span> <span class="lit">10</span><span class="pun">;</span>
<span class="kwd">const</span> <span class="kwd">int</span> <span class="pun">*</span> <span class="kwd">const</span><span class="pln"> p </span><span class="pun">=</span> <span class="pun">&amp;</span><span class="pln">a</span><span class="pun">;</span><span class="com">//p既是一个const指针，同时也指向了int类型的const值</span>
<span class="pun">*</span><span class="pln">p </span><span class="pun">=</span> <span class="lit">11</span><span class="pun">;</span>    <span class="com">//编译错误，指向的对象是只读的，不可通过p进行改变</span><span class="pln">
p </span><span class="pun">=</span> <span class="pun">&amp;</span><span class="pln">b</span><span class="pun">;</span>     <span class="com">//编译错误，p是一个const指针，只读，不可变</span></pre><p>看完上面几种情况之后是否会觉得混乱，并且难以记忆呢？我们使用一句话总结：</p><p>const 放在 * 的左侧任意位置，限定了该指针指向的对象是只读的；const放在 * 的右侧，限定了指针本身是只读的，即不可变的。</p><p>如果还不是很好理解，我们可以这样来看，去掉类型说明符，查看 const修饰的内容，上面三种情况去掉类型说明符 int 之后，如下：</p><pre class="prettyprint prettyprinted"><span class="kwd">const</span> <span class="pun">*</span><span class="pln">p</span><span class="pun">;</span> <span class="com">//修饰*p，指针指向的对象不可变</span>
<span class="pun">*</span> <span class="kwd">const</span><span class="pln"> p</span><span class="pun">;</span> <span class="com">//修饰p，指针不可变</span>
<span class="kwd">const</span> <span class="pun">*</span> <span class="kwd">const</span><span class="pln"> p</span><span class="pun">;</span> <span class="com">//第一个修饰了*p，第二个修饰了p，两者都不可变</span></pre><p>const 右边修饰谁，就说明谁是不可变的。上面的说法仅仅是帮助理解和记忆。借助上面这种理解，就会发现以下几种等价情况：</p><pre class="prettyprint prettyprinted"><span class="kwd">const</span> <span class="kwd">int</span><span class="pln"> NUM </span><span class="pun">=</span> <span class="lit">10</span><span class="pun">;</span> <span class="com">//与int const NUM等价</span>
<span class="kwd">int</span><span class="pln"> a </span><span class="pun">=</span> <span class="lit">9</span><span class="pun">;</span>
<span class="kwd">const</span> <span class="kwd">int</span> <span class="pun">*</span><span class="pln">p  </span><span class="pun">=</span> <span class="pun">&amp;</span><span class="pln">a</span><span class="pun">;</span><span class="com">//与int const *p等价</span>
<span class="kwd">const</span> <span class="kwd">int</span><span class="pln"> arr</span><span class="pun">[]</span> <span class="pun">=</span> <span class="pun">{</span><span class="lit">0</span><span class="pun">,</span><span class="lit">0</span><span class="pun">,</span><span class="lit">2</span><span class="pun">,</span><span class="lit">3</span><span class="pun">,</span><span class="lit">4</span><span class="pun">};</span> <span class="com">//与int const arr[]等价</span></pre><hr><p><strong>角度1</strong>： 就定义常量说的话， const 定义的常数是变量 也带类型， #define 定义的只是个常数 不带类型。</p><p><strong>角度2</strong>： 就起作用的阶段而言，#define 是在编译的预处理阶段起作用，而 const 是在 编译、运行的时候起作用。</p><p><strong>角度3</strong>： 就起作用的方式而言，#define 只是简单的字符串替换，没有类型检查。而 const 有对应的数据类型，是要进行判断的，可以避免一些低级的错误。 正因为 define 只是简单的字符串替换会导致边界效应，具体举例可以参考下面代码：</p><pre class="prettyprint prettyprinted"><span class="com">#define</span><span class="pln"> N </span><span class="lit">2</span><span class="pun">+</span><span class="lit">3</span>     <span class="com">// 我们预想的 N 值是 5，我们这样使用 </span>
<span class="typ">Ndouble</span><span class="pln"> a </span><span class="pun">=</span><span class="pln"> N</span><span class="pun">/</span><span class="lit">2</span><span class="pun">;</span>  <span class="com">// 我们预想的  a 的值是 2.5，可实际上 a 的值是 3.5</span></pre><p><strong>角度4</strong>： 就空间占用而言， 例如：</p><pre class="prettyprint prettyprinted"><span class="com">#define</span><span class="pln"> PI </span><span class="lit">3.14</span>     <span class="com">//预处理后 占用代码段空间</span>
<span class="kwd">const</span> <span class="kwd">float</span><span class="pln"> PI</span><span class="pun">=</span><span class="lit">3.14</span><span class="pun">;</span>    <span class="com">// 本质上还是一个 float，占用数据段空间</span></pre><p><strong>角度5</strong>： 从代码调试的方便程度而言, const 常量可以进行调试的，#define 是不能进行调试的，因为在预编译阶段就已经替换掉了</p><p><strong>角度6</strong>： 从是否可以再定义的角度而言, const 不足的地方，是与生俱来的，const 不能重定义，而 #define 可以通过 #undef 取消某个符号的定义，再重新定义。</p></div><footer class="post__inner post__footer"><p class="post__last-updated">This article was updated on August 25, 2022</p><div class="post__share"><h3>Share post:</h3></div><div class="post__bio"><div><h3><a href="https://yylh.github.io/fly/authors/fly/" class="invert" rel="author">fly</a></h3></div></div></footer></article></div></div><div id="sidebar"><div class="inner"><nav id="menu"><header class="major"><h2>Menu</h2></header><ul><li class="active"><a href="https://yylh.github.io/fly/this-is-big.html" title="itemToTag" target="_self">mitem</a></li></ul></nav><section><header class="major"><h2>Get in touch</h2></header><p>Sed varius enim lorem ullamcorper dolore aliquam aenean ornare velit lacus,ac varius enim lorem ullamcorper dolore. Proin sed aliqu facilisis ante interdum. Sed nulla amet lorem feugiat tempus aliquam.</p><ul class="contact"><li class="icon solid fa-envelope"><a href="#">information@untitled.tld</a></li><li class="icon solid fa-phone">(000) 000-0000</li><li class="icon solid fa-home">1234 Somewhere Road #8254<br>Nashville, TN 00000-0000</li></ul></section><footer id="footer"><p class="copyright">© Editorial 2 - All rights reserved<br>Design by: <a href="https://html5up.net" target="_blank" rel="noopener">HTML5 UP</a>, Powered by Publii</p></footer></div></div></div><script src="https://yylh.github.io/fly/assets/js/jquery.min.js?v=7c14a783dfeb3d238ccd3edd840d82ee"></script><script src="https://yylh.github.io/fly/assets/js/browser.min.js?v=c07298dd19048a8a69ad97e754dfe8d0"></script><script src="https://yylh.github.io/fly/assets/js/breakpoints.min.js?v=81a479eb099e3b187613943b085923b8"></script><script src="https://yylh.github.io/fly/assets/js/util.min.js?v=cbdaf7c20ac2883c77ae23acfbabd47e"></script><script src="https://yylh.github.io/fly/assets/js/main.min.js?v=08add7f6d435054ad38ec38d7cf8be40"></script><script>var images=document.querySelectorAll("img[loading]");for(var i=0;i<images.length;i++){if(images[i].complete){images[i].classList.add("is-loaded")}else{images[i].addEventListener("load",function(){this.classList.add("is-loaded")},false)}};</script></body></html>