<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>fly</title>
    <link href="https://yylh.github.io/fly/feed.xml" rel="self" />
    <link href="https://yylh.github.io/fly" />
    <updated>2022-08-25T17:39:47+08:00</updated>
    <author>
        <name>fly</name>
    </author>
    <id>https://yylh.github.io/fly</id>

    <entry>
        <title>dd</title>
        <author>
            <name>fly</name>
        </author>
        <link href="https://yylh.github.io/fly/dd.html"/>
        <id>https://yylh.github.io/fly/dd.html</id>

        <updated>2022-08-25T17:39:35+08:00</updated>
            <summary>
                <![CDATA[
                    C++ 变量作用域 C++ 全局变量、局部变量、静态全局变量、静态局部变量的区别 C++ 变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为 6 种：全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。 从作用域看： 全局变量具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量。 静态局部变量具有局部作用域，它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。 局部变量也只有局部作用域，它是自动对象（auto），它在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。 静态全局变量也具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。 从分配内存空间看： 全局变量，静态局部变量，静态全局变量都在静态存储区分配空间，而局部变量在栈里分配空间。 全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                
  <p>
    C++ 变量作用域
  </p>

  <p>
    C++ 全局变量、局部变量、静态全局变量、静态局部变量的区别
<br>
<br>C++ 变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为 6 种：全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。
<br>
<br>从作用域看：
<br>
<br>全局变量具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量。
<br>
<br>静态局部变量具有局部作用域，它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。
<br>
<br>局部变量也只有局部作用域，它是自动对象（auto），它在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。
<br>
<br>静态全局变量也具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。
<br>
<br>从分配内存空间看：
<br>
<br>全局变量，静态局部变量，静态全局变量都在静态存储区分配空间，而局部变量在栈里分配空间。
<br>
<br>全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。
<br>
<br> 1)、静态变量会被放在程序的静态数据存储区（数据段）(全局可见)中，这样可以在下一次调用的时候还可以保持原来的赋值。这一点是它与堆栈变量和堆变量的区别。
<br> 2)、变量用static告知编译器，自己仅仅在变量的作用范围内可见。这一点是它与全局变量的区别。
<br>从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。因此static 这个说明符在不同的地方所起的作用是不同的。应予以注意。
<br>
<br>Tips:
<br>
<br>A、若全局变量仅在单个C文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度；
<br>B、若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度；
<br>C、设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题，因为他们都放在静态数据存储区，全局可见；
<br>D、如果我们需要一个可重入的函数，那么，我们一定要避免函数中使用static变量(这样的函数被称为：带“内部存储器”功能的的函数)
<br>E、函数中必须要使用static变量情况:比如当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针。
<br>-----------------------------------------------------------------------------------------------------------
<br>
<br>static 全局变量:改变作用范围，不改变存储位置
<br>
<br>static 局部变量：改变存储位置，不改变作用范围
<br>
<br>静态函数 ：在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。
<br>
<br>如果在一个源文件中定义的函数，只能被本文件中的函数调用，而不能被同一程序其它文件中的函数调用，这种函数也称为内部函数。定义一个内部函数，只需在函数类型前再加一个“static”关键字即可。
  </p>

    <h2 id="static">
      类里的static
    </h2>

  <p>
    1.static 修饰类的成员变量
<br>
<br> 1). 静态成员变量是先于类的对象而存在
<br> 2). 这个类的所有对象共用一个静态成员
<br> 3). 如果静态成员是公有的，那么可以直接通过类名调用
<br> 4). 静态成员数据在声明时候类外初始化
<br>#include <iostream>
<br>
<br>using namespace std;
<br>class Data
<br>{
<br>public:
<br>    Data(){}
<br>    ~Data(){}
<br>    void show()
<br>    {
<br>        cout&lt;<this->data&lt;&lt;" "&lt;<number<<endl; <br="">    }
<br>
<br>    static void showData()//先于类的对象而存在
<br>    {
<br>        //这方法调用的时候不包含this指针
<br>        cout&lt;&lt;" "&lt;<number<<endl; <br="">    }
<br>
<br>private:
<br>    int data;
<br>public:
<br>    static int number; //静态数据在声明时候类外初始化
<br>};
<br>int Data::number=0;//静态成员初始化
<br>
<br>int main()
<br>{
<br>    Data::showData();//通过类名直接调用
<br>
<br>
<br>    Data::number = 100;//通过类名直接使用
<br>    Data d;
<br>    d.show();
<br>    d.showData();//通过对象调用
<br>
<br>    cout &lt;&lt; "Hello World!" &lt;&lt; endl;
<br>    return 0;
<br>}
<br>2.static 修饰类的成员方法
<br>
<br> 1). 静态成员函数是先于类的对象而存在
<br> 2). 可用类名直接调用（公有）
<br> 3). 在静态成员函数中没有this指针，所以不能使用非静态成员
<br>const 修饰--常量 ---- const修饰的常量代替宏定义
<br>
<br>修饰成员变量
<br>
<br>const int data;
<br>const 修饰的成员变量必须在构造方法的参数列表初始化（const static int pdata=10;除外）const 修饰的成员变量不能被修改
<br>
<br>修饰成员方法
<br>
<br>void showData()const{ }
<br>const 修饰的成员函数中不能修改成员变量，不能调用非 const 修饰的函数</number<<endl;></number<<endl;></this-></iostream>
  </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>this is BIG</title>
        <author>
            <name>fly</name>
        </author>
        <link href="https://yylh.github.io/fly/this-is-big.html"/>
        <id>https://yylh.github.io/fly/this-is-big.html</id>

        <updated>2022-08-25T17:39:47+08:00</updated>
            <summary>
                <![CDATA[
                    const关键字 const是constant的简写，只要一个变量前面用const来修饰，就意味着该变量里的数据可以被访问，不能被修改。也就是说const意味着只读（readonly）。 规则：const离谁近，谁就不能被修改； const修饰一个变量，一定要给这个变量初始化值，若不初始化，后面就无法初始化。 本质：const在谁后面谁就不可以修改，const在最前面则将其后移一位，二者等效。 const关键字作用 const关键字应用 Bjarne在他的The C++ Programming Language里面给出过一个助记的方法：把一个声明从右向左读。 char * const cp; ( * 读成 pointer to&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p data-title="C++ const 关键字" data-commid="11267,15416, 16271">const关键字</p>
<p><strong>         const</strong>是<strong>constant</strong>的简写，只要一个变量前面用const来修饰，就意味着该变量里的数据可以被访问，不能被修改。也就是说const意味着只读（readonly）。</p>
<p><strong>规则：const离谁近，谁就不能被修改；</strong></p>
<p>const修饰一个变量，一定要给这个变量初始化值，若不初始化，后面就无法初始化。</p>
<p><strong>本质：const在谁后面谁就不可以修改，const在最前面则将其后移一位，二者等效。</strong></p>
<p><strong>const关键字作用</strong></p>
<ul>
<li><i class="fa fa-circle" aria-hidden="true"></i>为给读你代码的人传达非常有用的信息，声明一个参数为常量是为了告诉用户这个参数的应用目的；</li>
<li><i class="fa fa-circle" aria-hidden="true"></i>通过给优化器一些附加信息，使关键字const也许能产生更紧凑的代码；</li>
<li><i class="fa fa-circle" aria-hidden="true"></i>合理使用关键字const可以使编译器很自然的保护那些不希望被修改的参数，防止无意的代码修改，可以减少bug的出现；</li>
</ul>
<p><strong>const关键字应用</strong></p>
<ul>
<li><i class="fa fa-circle" aria-hidden="true"></i>欲阻止一个变量被改变，可使用const，在定义该const变量时，需先初始化，以后就没有机会改变他了；</li>
<li><i class="fa fa-circle" aria-hidden="true"></i>对指针而言，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；</li>
<li><i class="fa fa-circle" aria-hidden="true"></i>在一个函数声明中，const可以修饰形参表明他是一个输入参数，在函数内部不可以改变其值；</li>
<li><i class="fa fa-circle" aria-hidden="true"></i>对于类的成员函数，有时候必须指定其为const类型，表明其是一个常函数，不能修改类的成员变量；</li>
<li><i class="fa fa-circle" aria-hidden="true"></i>对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。</li>
</ul>
<hr>
<h2 class="align-center">const char*, char const*, char*const 的区别</h2>
<p>Bjarne在他的The C++ Programming Language里面给出过一个助记的方法：<strong>把一个声明从右向左读</strong>。</p>
<pre class="prettyprint prettyprinted"><span class="kwd">char</span> <span class="pun">*</span> <span class="kwd">const</span><span class="pln"> cp</span><span class="pun">;</span> <span class="pun">(</span> <span class="pun">*</span> <span class="pun">读成</span><span class="pln"> pointer to </span><span class="pun">)</span><span class="pln"> 
cp </span><span class="kwd">is</span><span class="pln"> a </span><span class="kwd">const</span><span class="pln"> pointer to </span><span class="kwd">char</span> 

<span class="kwd">const</span> <span class="kwd">char</span> <span class="pun">*</span><span class="pln"> p</span><span class="pun">;</span><span class="pln"> 
p </span><span class="kwd">is</span><span class="pln"> a pointer to </span><span class="kwd">const</span> <span class="kwd">char</span><span class="pun">;</span> 

<span class="kwd">char</span> <span class="kwd">const</span> <span class="pun">*</span><span class="pln"> p</span><span class="pun">;</span> <br><span class="pln">p </span><span class="kwd">is</span><span class="pln"> a pointer to </span><span class="kwd">const</span> <span class="kwd">char</span><span class="pun">;</span> </pre>
<p>同上因为C++里面没有const*的运算符，所以const只能属于前面的类型。</p>
<p>修饰指针的情况比较多，主要有以下几种情况：</p>
<p>1、const 修饰 <strong>*p</strong>，指向的对象只读，指针的指向可变：</p>
<pre class="prettyprint prettyprinted"><span class="kwd">int</span><span class="pln"> a </span><span class="pun">=</span> <span class="lit">9</span><span class="pun">;</span>
<span class="kwd">int</span><span class="pln"> b </span><span class="pun">=</span> <span class="lit">10</span><span class="pun">;</span>
<span class="kwd">const</span> <span class="kwd">int</span> <span class="pun">*</span><span class="pln">p </span><span class="pun">=</span> <span class="pun">&amp;</span><span class="pln">a</span><span class="pun">;</span><span class="com">//p是一个指向int类型的const值,与int const *p等价</span>
<span class="pun">*</span><span class="pln">p </span><span class="pun">=</span> <span class="lit">11</span><span class="pun">;</span>    <span class="com">//编译错误，指向的对象是只读的，不可通过p进行改变</span><span class="pln">
p </span><span class="pun">=</span> <span class="pun">&amp;</span><span class="pln">b</span><span class="pun">;</span>     <span class="com">//合法，改变了p的指向</span></pre>
<p>这里为了便于理解，可认为const修饰的是 *p，通常使用 <strong>*</strong> 对指针进行解引用来访问对象，因而，该对象是只读的。</p>
<p>2、const 修饰 p，指向的对象可变，指针的指向不可变：</p>
<pre class="prettyprint prettyprinted"><span class="kwd">int</span><span class="pln"> a </span><span class="pun">=</span> <span class="lit">9</span><span class="pun">;</span>
<span class="kwd">int</span><span class="pln"> b </span><span class="pun">=</span> <span class="lit">10</span><span class="pun">;</span>
<span class="kwd">int</span> <span class="pun">*</span> <span class="kwd">const</span><span class="pln"> p </span><span class="pun">=</span> <span class="pun">&amp;</span><span class="pln">a</span><span class="pun">;</span><span class="com">//p是一个const指针</span>
<span class="pun">*</span><span class="pln">p </span><span class="pun">=</span> <span class="lit">11</span><span class="pun">;</span>    <span class="com">//合法，</span><span class="pln">
p </span><span class="pun">=</span> <span class="pun">&amp;</span><span class="pln">b</span><span class="pun">;</span>     <span class="com">//编译错误，p是一个const指针，只读，不可变</span></pre>
<p>3、指针不可改变指向，指向的内容也不可变</p>
<pre class="prettyprint prettyprinted"><span class="kwd">int</span><span class="pln"> a </span><span class="pun">=</span> <span class="lit">9</span><span class="pun">;</span>
<span class="kwd">int</span><span class="pln"> b </span><span class="pun">=</span> <span class="lit">10</span><span class="pun">;</span>
<span class="kwd">const</span> <span class="kwd">int</span> <span class="pun">*</span> <span class="kwd">const</span><span class="pln"> p </span><span class="pun">=</span> <span class="pun">&amp;</span><span class="pln">a</span><span class="pun">;</span><span class="com">//p既是一个const指针，同时也指向了int类型的const值</span>
<span class="pun">*</span><span class="pln">p </span><span class="pun">=</span> <span class="lit">11</span><span class="pun">;</span>    <span class="com">//编译错误，指向的对象是只读的，不可通过p进行改变</span><span class="pln">
p </span><span class="pun">=</span> <span class="pun">&amp;</span><span class="pln">b</span><span class="pun">;</span>     <span class="com">//编译错误，p是一个const指针，只读，不可变</span></pre>
<p>看完上面几种情况之后是否会觉得混乱，并且难以记忆呢？我们使用一句话总结：</p>
<p>const 放在 * 的左侧任意位置，限定了该指针指向的对象是只读的；const放在 * 的右侧，限定了指针本身是只读的，即不可变的。</p>
<p>如果还不是很好理解，我们可以这样来看，去掉类型说明符，查看 const修饰的内容，上面三种情况去掉类型说明符 int 之后，如下：</p>
<pre class="prettyprint prettyprinted"><span class="kwd">const</span> <span class="pun">*</span><span class="pln">p</span><span class="pun">;</span> <span class="com">//修饰*p，指针指向的对象不可变</span>
<span class="pun">*</span> <span class="kwd">const</span><span class="pln"> p</span><span class="pun">;</span> <span class="com">//修饰p，指针不可变</span>
<span class="kwd">const</span> <span class="pun">*</span> <span class="kwd">const</span><span class="pln"> p</span><span class="pun">;</span> <span class="com">//第一个修饰了*p，第二个修饰了p，两者都不可变</span></pre>
<p>const 右边修饰谁，就说明谁是不可变的。上面的说法仅仅是帮助理解和记忆。借助上面这种理解，就会发现以下几种等价情况：</p>
<pre class="prettyprint prettyprinted"><span class="kwd">const</span> <span class="kwd">int</span><span class="pln"> NUM </span><span class="pun">=</span> <span class="lit">10</span><span class="pun">;</span> <span class="com">//与int const NUM等价</span>
<span class="kwd">int</span><span class="pln"> a </span><span class="pun">=</span> <span class="lit">9</span><span class="pun">;</span>
<span class="kwd">const</span> <span class="kwd">int</span> <span class="pun">*</span><span class="pln">p  </span><span class="pun">=</span> <span class="pun">&amp;</span><span class="pln">a</span><span class="pun">;</span><span class="com">//与int const *p等价</span>
<span class="kwd">const</span> <span class="kwd">int</span><span class="pln"> arr</span><span class="pun">[]</span> <span class="pun">=</span> <span class="pun">{</span><span class="lit">0</span><span class="pun">,</span><span class="lit">0</span><span class="pun">,</span><span class="lit">2</span><span class="pun">,</span><span class="lit">3</span><span class="pun">,</span><span class="lit">4</span><span class="pun">};</span> <span class="com">//与int const arr[]等价</span></pre>
<hr>
<p><strong>角度1</strong>： 就定义常量说的话， const 定义的常数是变量 也带类型， #define 定义的只是个常数 不带类型。</p>
<p><strong>角度2</strong>： 就起作用的阶段而言，#define 是在编译的预处理阶段起作用，而 const 是在 编译、运行的时候起作用。</p>
<p><strong>角度3</strong>： 就起作用的方式而言，#define 只是简单的字符串替换，没有类型检查。而 const 有对应的数据类型，是要进行判断的，可以避免一些低级的错误。 正因为 define 只是简单的字符串替换会导致边界效应，具体举例可以参考下面代码：</p>
<pre class="prettyprint prettyprinted"><span class="com">#define</span><span class="pln"> N </span><span class="lit">2</span><span class="pun">+</span><span class="lit">3</span>     <span class="com">// 我们预想的 N 值是 5，我们这样使用 </span>
<span class="typ">Ndouble</span><span class="pln"> a </span><span class="pun">=</span><span class="pln"> N</span><span class="pun">/</span><span class="lit">2</span><span class="pun">;</span>  <span class="com">// 我们预想的  a 的值是 2.5，可实际上 a 的值是 3.5</span></pre>
<p><strong>角度4</strong>： 就空间占用而言， 例如：</p>
<pre class="prettyprint prettyprinted"><span class="com">#define</span><span class="pln"> PI </span><span class="lit">3.14</span>     <span class="com">//预处理后 占用代码段空间</span>
<span class="kwd">const</span> <span class="kwd">float</span><span class="pln"> PI</span><span class="pun">=</span><span class="lit">3.14</span><span class="pun">;</span>    <span class="com">// 本质上还是一个 float，占用数据段空间</span></pre>
<p><strong>角度5</strong>： 从代码调试的方便程度而言, const 常量可以进行调试的，#define 是不能进行调试的，因为在预编译阶段就已经替换掉了</p>
<p><strong>角度6</strong>： 从是否可以再定义的角度而言, const 不足的地方，是与生俱来的，const 不能重定义，而 #define 可以通过 #undef 取消某个符号的定义，再重新定义。</p>
            ]]>
        </content>
    </entry>
</feed>
